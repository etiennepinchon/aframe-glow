!function(e){var t={};function r(i){if(t[i])return t[i].exports;var o=t[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(i,o,function(t){return e[t]}.bind(null,o));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const i=new THREE.Vector3,o=new THREE.Vector3,s=new THREE.Vector3,n=new THREE.Vector3,a=new THREE.Vector3,u=new THREE.Vector3,f=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3,g=new THREE.Vector3,h=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],b=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],m=new THREE.Triangle;class p{static modify(e,t=1,r={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof r&&(r={}),void 0===r.split&&(r.split=!0),void 0===r.uvSmooth&&(r.uvSmooth=!1),void 0===r.preserveEdges&&(r.preserveEdges=!1),void 0===r.flatOnly&&(r.flatOnly=!1),void 0===r.maxTriangles&&(r.maxTriangles=1/0),!T(e))return e;let i=e.clone();if(r.split){const e=p.edgeSplit(i);i.dispose(),i=e}for(let e=0;e<t;e++){if(i.attributes.position.count/3<r.maxTriangles){let e;e=r.flatOnly?p.flat(i):p.smooth(i,r),i.groups.forEach(t=>{e.addGroup(4*t.start,4*t.count,t.materialIndex)}),i.dispose(),i=e}}return i}static edgeSplit(e){if(!T(e))return e;const t=null!==e.index?e.toNonIndexed():e.clone(),r=new THREE.BufferGeometry,i=x(t),a=t.attributes.position.count,c=t.getAttribute("position"),d=t.getAttribute("normal"),g={},h=[],b={},p=[];for(let e=0;e<a;e+=3){u.fromBufferAttribute(c,e+0),f.fromBufferAttribute(c,e+1),l.fromBufferAttribute(c,e+2),n.fromBufferAttribute(d,e);const t=_(u),r=_(f),i=_(l),o=m.set(u,f,l).getArea();if(p.push(!y(o,0)),!p[e/3]){h.push([]);continue}w(n,u,f,l);const s=_(n),a=[`${t}_${r}_${s}`,`${r}_${t}_${s}`,`${r}_${i}_${s}`,`${i}_${r}_${s}`,`${i}_${t}_${s}`,`${t}_${i}_${s}`],E=e/3;for(let e=0;e<a.length;e++)g[a[e]]||(g[a[e]]=[]),g[a[e]].push(E),b[a[e]]||(0!==e&&1!==e||(b[a[e]]=u.distanceTo(f)),2!==e&&3!==e||(b[a[e]]=f.distanceTo(l)),4!==e&&5!==e||(b[a[e]]=l.distanceTo(u)));h.push([a[0],a[2],a[4]])}i.forEach(e=>{const i=t.getAttribute(e);if(!i)return;const o=v(i,e);r.setAttribute(e,new THREE.BufferAttribute(o,i.itemSize))});const E=t.morphAttributes;for(const e in E){const t=[],i=E[e];for(let r=0,o=i.length;r<o;r++){if(i[r].count!==a)continue;const o=v(i[r],e,!0);t.push(new THREE.BufferAttribute(o,i[r].itemSize))}r.morphAttributes[e]=t}return r.morphTargetsRelative=t.morphTargetsRelative,t.dispose(),r;function v(e,i,n=!1){const c=a*e.itemSize*4,d=new e.array.constructor(c),m="position"===i&&!n&&t.groups.length>0;let E=void 0,y=void 0,v=0,_=0,w=e.itemSize;for(let i=0;i<a;i+=3){if(!p[i/3]){_+=3;continue}u.fromBufferAttribute(e,i+0),f.fromBufferAttribute(e,i+1),l.fromBufferAttribute(e,i+2);const n=i/3,a=h[n][0],c=h[n][1],x=h[n][2],T=g[a].length,R=g[c].length,S=g[x].length,H=3*v/w/3;if(0===T+R+S-3)A(d,v,w,u,f,l),v+=3*w;else{const e=b[a],t=b[c],r=b[x];(e>t||R<=1)&&(e>r||S<=1)&&T>1?(o.copy(u).add(f).divideScalar(2),S>1?(s.copy(l).add(u).divideScalar(2),A(d,v,w,u,o,s),v+=3*w,A(d,v,w,o,l,s),v+=3*w):(A(d,v,w,u,o,l),v+=3*w),R>1?(s.copy(f).add(l).divideScalar(2),A(d,v,w,o,f,s),v+=3*w,A(d,v,w,s,l,o),v+=3*w):(A(d,v,w,f,l,o),v+=3*w)):(t>r||S<=1)&&R>1?(o.copy(f).add(l).divideScalar(2),T>1?(s.copy(u).add(f).divideScalar(2),A(d,v,w,o,s,f),v+=3*w,A(d,v,w,s,o,u),v+=3*w):(A(d,v,w,f,o,u),v+=3*w),S>1?(s.copy(l).add(u).divideScalar(2),A(d,v,w,o,l,s),v+=3*w,A(d,v,w,s,u,o),v+=3*w):(A(d,v,w,l,u,o),v+=3*w)):S>1?(o.copy(l).add(u).divideScalar(2),R>1?(s.copy(f).add(l).divideScalar(2),A(d,v,w,l,o,s),v+=3*w,A(d,v,w,o,f,s),v+=3*w):(A(d,v,w,l,o,f),v+=3*w),T>1?(s.copy(u).add(f).divideScalar(2),A(d,v,w,u,s,o),v+=3*w,A(d,v,w,s,f,o),v+=3*w):(A(d,v,w,u,f,o),v+=3*w)):(A(d,v,w,u,f,l),v+=3*w)}m&&t.groups.forEach(e=>{e.start===i-_&&(void 0!==E&&void 0!==y&&r.addGroup(E,H-E,y),E=H,y=e.materialIndex)}),_=0}const x=3*v/w,T=new e.array.constructor(x);for(let e=0;e<x;e++)T[e]=d[e];return m&&void 0!==E&&void 0!==y&&r.addGroup(E,3*v/w/3-E,y),T}}static flat(e){if(!T(e))return e;const t=null!==e.index?e.toNonIndexed():e.clone(),r=new THREE.BufferGeometry,i=x(t),o=t.attributes.position.count;i.forEach(e=>{const i=t.getAttribute(e);i&&r.setAttribute(e,p.flatAttribute(i,o))});const s=t.morphAttributes;for(const e in s){const t=[],i=s[e];for(let e=0,r=i.length;e<r;e++)i[e].count===o&&t.push(p.flatAttribute(i[e],o));r.morphAttributes[e]=t}return r.morphTargetsRelative=t.morphTargetsRelative,t.dispose(),r}static flatAttribute(e,t){const r=t*e.itemSize*4,i=new e.array.constructor(r);let o=0,s=e.itemSize;for(let r=0;r<t;r+=3)u.fromBufferAttribute(e,r+0),f.fromBufferAttribute(e,r+1),l.fromBufferAttribute(e,r+2),c.copy(u).add(f).divideScalar(2),d.copy(f).add(l).divideScalar(2),g.copy(l).add(u).divideScalar(2),A(i,o,s,u,c,g),o+=3*s,A(i,o,s,f,d,c),o+=3*s,A(i,o,s,l,g,d),o+=3*s,A(i,o,s,c,d,g),o+=3*s;return new THREE.BufferAttribute(i,e.itemSize)}static smooth(e,t={}){if("object"!=typeof t&&(t={}),void 0===t.uvSmooth&&(t.uvSmooth=!1),void 0===t.preserveEdges&&(t.preserveEdges=!1),!T(e))return e;const r=null!==e.index?e.toNonIndexed():e.clone(),o=p.flat(r),s=new THREE.BufferGeometry,n=x(r),u=r.attributes.position.count,f=r.getAttribute("position"),l=o.getAttribute("position"),m={},E={},y={},v={};function w(e,t,r){E[e]||(E[e]={}),E[e][t]||(E[e][t]=[]),E[e][t].push(r)}function R(e,t){y[e]||(y[e]=[]),y[e].push(t)}function S(e,t){v[e]||(v[e]=new Set),v[e].add(t)}for(let e=0;e<u;e+=3){const t=_(b[0].fromBufferAttribute(f,e+0)),r=_(b[1].fromBufferAttribute(f,e+1)),i=_(b[2].fromBufferAttribute(f,e+2));w(t,r,e+1),w(t,i,e+2),w(r,t,e+0),w(r,i,e+2),w(i,t,e+0),w(i,r,e+1),c.copy(b[0]).add(b[1]).divideScalar(2),d.copy(b[1]).add(b[2]).divideScalar(2),g.copy(b[2]).add(b[0]).divideScalar(2);const o=_(c),s=_(d),n=_(g);R(o,e+2),R(s,e+0),R(n,e+1),S(t,o),S(t,n),S(r,o),S(r,s),S(i,s),S(i,n)}for(let e=0;e<o.attributes.position.count;e++){const t=_(a.fromBufferAttribute(l,e));m[t]||(m[t]=[]),m[t].push(e)}n.forEach(e=>{const t=r.getAttribute(e),i=o.getAttribute(e);if(void 0===t||void 0===i)return;const n=z(e,t,i);s.setAttribute(e,new THREE.BufferAttribute(n,i.itemSize))});const H=r.morphAttributes;for(const e in H){const t=[],r=H[e];for(let i=0,o=r.length;i<o;i++){if(r[i].count!==u)continue;const o=r[i],s=p.flatAttribute(r[i],r[i].count),n=z(e,o,s);t.push(new THREE.BufferAttribute(n,s.itemSize))}s.morphAttributes[e]=t}return s.morphTargetsRelative=r.morphTargetsRelative,o.dispose(),r.dispose(),s;function z(e,r,s){const n=o.attributes.position.count*s.itemSize,u=new r.array.constructor(n);let f=0;for(let n=0;n<o.attributes.position.count;n+=3){for(let o=0;o<3;o++)if("uv"!==e||t.uvSmooth)if("normal"===e){h[o].fromBufferAttribute(l,n+o);const e=_(h[o]),t=m[e],r=Object.keys(t).length,a=.75/r,u=1-a*r;b[o].fromBufferAttribute(s,n+o),b[o].multiplyScalar(u),t.forEach(e=>{i.fromBufferAttribute(s,e),i.multiplyScalar(a),b[o].add(i)})}else{b[o].fromBufferAttribute(s,n+o),h[o].fromBufferAttribute(l,n+o);const e=_(h[o]),u=E[e],f=y[e];if(u){if(t.preserveEdges){const t=v[e];let r=!0;for(const e of t)y[e].length%2!=0&&(r=!1);if(!r)continue}const s=Object.keys(u).length,n=1/s*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/s),2)),f=1-n*s;b[o].multiplyScalar(f);for(let e in u){const t=u[e];i.set(0,0,0);for(let e=0;e<t.length;e++)i.add(a.fromBufferAttribute(r,t[e]));i.divideScalar(t.length),i.multiplyScalar(n),b[o].add(i)}}else if(f&&2===f.length){const e=f.length,t=.125,s=1-t*e;b[o].multiplyScalar(s),f.forEach(e=>{i.fromBufferAttribute(r,e),i.multiplyScalar(t),b[o].add(i)})}}else b[o].fromBufferAttribute(s,n+o);A(u,f,s.itemSize,b[0],b[1],b[2]),f+=3*s.itemSize}return u}}}const E=Math.pow(10,2);function y(e,t,r=1e-5){return e<t+r&&e>t-r}function v(e,t=E){let r=(i=e*t)+(i>0?.5:-.5)<<0;var i;return 0==r&&(r=0),""+r}function _(e,t=E){return`${v(e.x,t)},${v(e.y,t)},${v(e.z,t)}`}function w(e,t,r,i){a.subVectors(t,r),e.subVectors(r,i),e.cross(a).normalize()}function x(e){const t=Object.keys(e.attributes);return Array.from(new Set(["position","normal","uv"].concat(t)))}function A(e,t,r,i,o,s){r>=1&&(e[t+0+0*r]=i.x,e[t+0+1*r]=o.x,e[t+0+2*r]=s.x),r>=2&&(e[t+1+0*r]=i.y,e[t+1+1*r]=o.y,e[t+1+2*r]=s.y),r>=3&&(e[t+2+0*r]=i.z,e[t+2+1*r]=o.z,e[t+2+2*r]=s.z),r>=4&&(e[t+3+0*r]=i.w,e[t+3+1*r]=o.w,e[t+3+2*r]=s.w)}function T(e){return void 0===e?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):e.isBufferGeometry?void 0===e.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===e.attributes.normal&&e.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}AFRAME.registerComponent("glow",{schema:{enabled:{default:!0},c:{type:"number",default:1},p:{type:"number",default:1.4},color:{type:"color",default:"#FFFF00"},scale:{type:"number",default:2},side:{type:"string",default:"front"}},init:function(){const e=this,t=function(){const t=document.querySelector("[camera]").object3D;e.camera=t;let r=THREE.FrontSide;"back"===e.data.side&&(r=THREE.BackSide),e.glowMaterial=new THREE.ShaderMaterial({uniforms:{c:{type:"f",value:e.data.c},p:{type:"f",value:e.data.p},glowColor:{type:"c",value:new THREE.Color(e.data.color)},viewVector:{type:"v3",value:t.position}},vertexShader:THREE.__GlowShader.vertexShader,fragmentShader:THREE.__GlowShader.fragmentShader,side:r,blending:THREE.AdditiveBlending,transparent:!0});const i=p.modify(e.el.object3DMap.mesh.geometry,2,{});e.glowMesh=new THREE.Mesh(i,e.glowMaterial),e.el.object3D.add(e.glowMesh),e.data.enabled||(e.glowMesh.visible=!1)};function r(){if(e.el.object3DMap.mesh)return t();e.el.addEventListener("model-loaded",t)}if(this.el.sceneEl.hasLoaded)return r();this.el.sceneEl.addEventListener("loaded",r)},update:function(){if(this.data.enabled){if(this.glowMesh){this.glowMesh.visible=!0,this.data.c<0&&(this.data.c=0),this.data.c>1&&(this.data.c=1),this.data.p<0&&(this.data.p=0),this.data.p>6&&(this.data.p=6),this.glowMesh.material.uniforms.c.value=this.data.c,this.glowMesh.material.uniforms.p.value=this.data.p,this.glowMesh.material.uniforms.glowColor.value.setHex(this.data.color.replace("#","0x"));let e=THREE.FrontSide;"back"===this.data.side&&(e=THREE.BackSide),this.glowMesh.material.side=e}}else this.glowMesh&&(this.glowMesh.visible=!1)},tick:function(){if(this.glowMesh){if(this.glowMesh.rotation.set(this.el.object3D.rotation.x,this.el.object3D.rotation.y,this.el.object3D.rotation.z),this.glowMesh.scale.set(this.el.object3D.scale.x*this.data.scale,this.el.object3D.scale.y*this.data.scale,this.el.object3D.scale.z*this.data.scale),!this.camera)return;this.glowMesh.material.uniforms.viewVector.value=(new THREE.Vector3).subVectors(this.camera.position,this.glowMesh.position)}},remove:function(){if(!this.glowMesh)return;this.el.sceneEl.object3D.remove(this.glowMesh),this.glowMesh=null,this.glowMaterial=null},pause:function(){},play:function(){}}),THREE.__GlowShader={vertexShader:["uniform vec3 viewVector;","uniform float c;","uniform float p;","varying float intensity;","void main() ","{","vec3 vNormal = normalize( normalMatrix * normal );","vec3 vNormel = normalize( normalMatrix * viewVector );","intensity = pow( c - dot(vNormal, vNormel), p );","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 glowColor;","varying float intensity;","void main() ","{","vec3 glow = glowColor * intensity;","gl_FragColor = vec4( glow, 1.0 );","}"].join("\n")};var R=function(e,t,r,i,o,s){this.array_type=i,this.register_type=r,this.unit_size=o,this.accessors=s,this.buffer=new i(e*o),this.register=[],this.length=0,this.real_length=e,this.available_registers=t;for(var n=0;n<t;n++)this.register.push(new r)};function S(e){var t=["x","y","z"],r=["x","y"],i=new R(0,3,THREE.Vector3,Float32Array,3,t),o=new R(0,3,THREE.Face3,Uint32Array,3,["a","b","c"]),s=new R(0,3,THREE.Vector2,Float32Array,2,r),n=new R(0,3,THREE.Vector3,Float32Array,3,t);i.from_existing(e.getAttribute("position").array),o.from_existing(e.index.array),s.from_existing(e.getAttribute("uv").array),function(e){var t=["x","y","z"],r=new R(0,5,THREE.Vector3,Float32Array,3,t),i=new R(0,3,THREE.Face3,Uint32Array,3,["a","b","c"]);r.from_existing(e.getAttribute("position").array);var o,s=new R(3*r.length,4,THREE.Vector3,Float32Array,3,t),n=new R(r.length,1,(function(){this.x=0}),Float32Array,1,["x"]);s.length=r.length,i.from_existing(e.index.array);for(var a=[0,0,0],u=0,f=i.length;u<f;u++)i.index_to_register(u,0),r.index_to_register(i.register[0].a,0),r.index_to_register(i.register[0].b,1),r.index_to_register(i.register[0].c,2),s.register[0].subVectors(r.register[1],r.register[0]),s.register[1].subVectors(r.register[2],r.register[1]),s.register[0].cross(s.register[1]),o=Math.abs(s.register[0].length()),n.buffer[i.register[0].a]+=o,n.buffer[i.register[0].b]+=o,n.buffer[i.register[0].c]+=o;for(u=0,f=i.length;u<f;u++)i.index_to_register(u,0),r.index_to_register(i.register[0].a,0),r.index_to_register(i.register[0].b,1),r.index_to_register(i.register[0].c,2),s.register[0].subVectors(r.register[1],r.register[0]),s.register[1].subVectors(r.register[2],r.register[0]),s.register[3].set(0,0,0),s.register[3].x=s.register[0].y*s.register[1].z-s.register[0].z*s.register[1].y,s.register[3].y=s.register[0].z*s.register[1].x-s.register[0].x*s.register[1].z,s.register[3].z=s.register[0].x*s.register[1].y-s.register[0].y*s.register[1].x,s.register[0].cross(s.register[1]),o=Math.abs(s.register[0].length()),a[0]=o/n.buffer[i.register[0].a],a[1]=o/n.buffer[i.register[0].b],a[2]=o/n.buffer[i.register[0].c],s.buffer[3*i.register[0].a+0]+=s.register[3].x*a[0],s.buffer[3*i.register[0].a+1]+=s.register[3].y*a[0],s.buffer[3*i.register[0].a+2]+=s.register[3].z*a[0],s.buffer[3*i.register[0].b+0]+=s.register[3].x*a[1],s.buffer[3*i.register[0].b+1]+=s.register[3].y*a[1],s.buffer[3*i.register[0].b+2]+=s.register[3].z*a[1],s.buffer[3*i.register[0].c+0]+=s.register[3].x*a[2],s.buffer[3*i.register[0].c+1]+=s.register[3].y*a[2],s.buffer[3*i.register[0].c+2]+=s.register[3].z*a[2];s.trim_size(),e.addAttribute("normal",new THREE.BufferAttribute(s.buffer,3))}(e),n.from_existing(e.getAttribute("normal").array);for(var a=new R(3*o.length,3,THREE.Vector3,Float32Array,3,t),u=new R(3*o.length,3,THREE.Vector3,Float32Array,3,t),f=new R(3*o.length,3,THREE.Vector2,Float32Array,2,r),l=0,c=o.length;l<c;l++)o.index_to_register(l,0),i.index_to_register(o.register[0].a,0),i.index_to_register(o.register[0].b,1),i.index_to_register(o.register[0].c,2),a.push_element(i.register[0]),a.push_element(i.register[1]),a.push_element(i.register[2]),0!==s.length&&(s.index_to_register(3*l+0,0),s.index_to_register(3*l+1,1),s.index_to_register(3*l+2,2),f.push_element(s.register[0]),f.push_element(s.register[1]),f.push_element(s.register[2])),n.index_to_register(o.register[0].a,0),n.index_to_register(o.register[0].b,1),n.index_to_register(o.register[0].c,2),u.push_element(n.register[0]),u.push_element(n.register[1]),u.push_element(n.register[2]);return a.trim_size(),f.trim_size(),u.trim_size(),e.index=null,e.addAttribute("position",new THREE.BufferAttribute(a.buffer,3)),e.addAttribute("normal",new THREE.BufferAttribute(u.buffer,3)),0!==f.length&&e.addAttribute("uv",new THREE.BufferAttribute(f.buffer,2)),e}R.prototype={constructor:R,index_to_register:function(e,t,r){var i=e*this.unit_size;if(t>=this.available_registers)throw new Error("THREE.BufferSubdivisionModifier: Not enough registers in TypedArrayHelper.");if(e>this.length)throw new Error("THREE.BufferSubdivisionModifier: Index is out of range in TypedArrayHelper.");for(var o=0;o<this.unit_size;o++)this.register[t][this.accessors[o]]=this.buffer[i+o]},resize:function(e){var t;(0===e&&(e=8),e<this.length)?this.buffer=this.buffer.subarray(0,this.length*this.unit_size):this.buffer.length<e*this.unit_size?((t=new this.array_type(e*this.unit_size)).set(this.buffer),this.buffer=t,this.real_length=e):((t=new this.array_type(e*this.unit_size)).set(this.buffer.subarray(0,this.length*this.unit_size)),this.buffer=t,this.real_length=e)},from_existing:function(e){var t=e.length;this.buffer=new this.array_type(t),this.buffer.set(e),this.length=e.length/this.unit_size,this.real_length=this.length},push_element:function(e){this.length+1>this.real_length&&this.resize(2*this.real_length);for(var t=this.length*this.unit_size,r=0;r<this.unit_size;r++)this.buffer[t+r]=e[this.accessors[r]];this.length++},trim_size:function(){this.length<this.real_length&&this.resize(this.length)}},THREE.BufferSubdivisionModifier=function(e){this.subdivisions=void 0===e?1:e},THREE.BufferSubdivisionModifier.prototype.modify=function(e){e instanceof THREE.Geometry?(e.mergeVertices(),void 0===e.normals&&(e.normals=[]),e=convertGeometryToIndexedBuffer(e)):e instanceof THREE.BufferGeometry||console.error("THREE.BufferSubdivisionModifier: Geometry is not an instance of THREE.BufferGeometry or THREE.Geometry");for(var t=this.subdivisions;t-- >0;)this.smooth(e);return S(e)};var H=function(e,t){this.a=e,this.b=t,this.faces=[],this.newEdge=null};!function(){var e=["a","b","c"],t=["x","y","z"],r=["x","y"];function i(e,t,r){return r[Math.min(e,t)+"_"+Math.max(e,t)]}function o(e,t,r,i,o,s){var n,a=Math.min(e,t),u=Math.max(e,t),f=a+"_"+u;f in i?n=i[f]:(n=new H(a,u),i[f]=n),n.faces.push(o),s[e].edges.push(n),s[t].edges.push(n)}function s(e,t){e.push_element(t)}function n(e,t){return Math.abs(t-e)/2+Math.min(e,t)}function a(e,t,r,i){e.push_element(t),e.push_element(r),e.push_element(i)}THREE.BufferSubdivisionModifier.prototype.smooth=function(u){var f,l,c,d,g,h,b,m,p,E,y,v,_;f=new R(0,3,THREE.Vector3,Float32Array,3,t),l=new R(0,3,THREE.Face3,Uint32Array,3,e),c=new R(0,3,THREE.Vector2,Float32Array,2,r),f.from_existing(u.getAttribute("position").array),l.from_existing(u.index.array),c.from_existing(u.getAttribute("uv").array);var w,x,A,T,S,H,z,M=!1;void 0!==c&&0!==c.length&&(M=!0),function(e,t,r,i){var s,n,a;for(s=0,n=e.length;s<n;s++)r[s]={edges:[]};for(s=0,n=t.length;s<n;s++)t.index_to_register(s,0),o((a=t.register[0]).a,a.b,0,i,s,r),o(a.b,a.c,0,i,s,r),o(a.c,a.a,0,i,s,r)}(f,l,v=new Array(f.length),_={});var B=(d=new R(2*u.getAttribute("position").array.length/3,2,THREE.Vector3,Float32Array,3,t)).register[1];for(m in _){for(x=_[m],A=d.register[0],S=3/8,H=1/8,2!==(z=x.faces.length)&&(S=.5,H=0),f.index_to_register(x.a,0),f.index_to_register(x.b,1),A.addVectors(f.register[0],f.register[1]).multiplyScalar(S),B.set(0,0,0),E=0;E<z;E++){for(l.index_to_register(x.faces[E],0),T=l.register[0],y=0;y<3&&(f.index_to_register(T[e[y]],2),w=f.register[2],T[e[y]]===x.a||T[e[y]]===x.b);y++);B.add(w)}B.multiplyScalar(H),A.add(B),x.newEdge=d.length,d.push_element(A)}var V,j,F,$,G,O,D,I,N,k,C=d.length;for(m=0,p=f.length;m<p;m++){for(f.index_to_register(m,0,t),O=f.register[0],3===(b=(G=v[m].edges).length)?V=3/16:b>3&&(V=3/(8*b)),j=1-b*V,F=V,b<=2&&2===b&&(j=3/4,F=1/8),D=O.multiplyScalar(j),B.set(0,0,0),E=0;E<b;E++)w=($=G[E]).a!==m?$.a:$.b,f.index_to_register(w,1,t),B.add(f.register[1]);B.multiplyScalar(F),D.add(B),d.push_element(D,t)}g=new R(4*u.index.array.length/3,1,THREE.Face3,Float32Array,3,e);var L=(h=new R(4*u.getAttribute("uv").array.length/2,3,THREE.Vector2,Float32Array,2,r)).register[0],P=h.register[1],U=h.register[2],q=g.register[0];for(m=0,p=l.length;m<p;m++)if(l.index_to_register(m,0),I=i((T=l.register[0]).a,T.b,_).newEdge,N=i(T.b,T.c,_).newEdge,k=i(T.c,T.a,_).newEdge,q.set(I,N,k),s(g,q),q.set(T.a+C,I,k),s(g,q),q.set(T.b+C,N,I),s(g,q),q.set(T.c+C,k,N),s(g,q),!0===M){c.index_to_register(3*m+0,0),c.index_to_register(3*m+1,1),c.index_to_register(3*m+2,2);var J=c.register[0],K=c.register[1],Q=c.register[2];L.set(n(J.x,K.x),n(J.y,K.y)),P.set(n(K.x,Q.x),n(K.y,Q.y)),U.set(n(J.x,Q.x),n(J.y,Q.y)),a(h,L,P,U),a(h,J,L,U),a(h,K,P,L),a(h,Q,U,P)}g.trim_size(),d.trim_size(),h.trim_size(),u.setIndex(new THREE.BufferAttribute(g.buffer,3)),u.addAttribute("position",new THREE.BufferAttribute(d.buffer,3)),u.addAttribute("uv",new THREE.BufferAttribute(h.buffer,2))}}()}]);